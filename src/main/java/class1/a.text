1.评估算法优劣的核心指标是什么？
    时间复杂度（流程决定）
    额外空间复杂度（流程决定）
    常数项时间（实现细节决定）

2.常见的常数时间的操作
    一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
    常见的算数运算（+ - * / %）
    常见的位运算（>> >>> << & | ^ ~）
    赋值 比较 自增 自减
    数组寻址

3.如何确定算法流程的时间复杂度
    当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉
    记为：O（忽略掉系数的高阶项）
    评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

4.常见的时间复杂度排名从好到差
    O(1) > O(logN) > O(N) > O(N*logN) > O(N^2) > O(N^3) > O(N^k) > O(2^N) > O(3^N) > O(N!)

5.二分法
    经常见到的类型是在一个有序的数据上，开展二分搜索，但有序真的不是二分法的必要条件，只要能正确构建左右两侧的淘汰逻辑就可以二分。
    使用场景：
    1> 在一个有序数据组，找某个数是否存在
    2> 在一个有序数组中，找>=某个数最左侧的位置
    3> 在一个有序数组中，找<=某个数最右侧的位置
    4> 局部最小值问题 （①数组中任意一个位置元素比左侧位置小 ②数组中任意一个位置元素比右侧位置小 ③数组中任意一个位置元素比左侧和右侧位置小）
        例如：[1,2,5,7,6,9] 1比2小 满足②,6比7小 满足①,6比7和9都小 满足③
        例题：给定任意一个无序数组，任意两个相邻的数不等，要求返回一个局部最小位置

6.异或运算的性质与拓展
    异或运算就记成无进位相加
    1> 0 ^ N == N   N ^ N == 0
    2> 异或运算满足交换律和结合律(a ^ b ^ c == a ^ c ^ b)
    3> 不使用额外变量交换两个数
    4> 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数
    5> 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数
    6> 统计一个int类型数字二进制中包含几个1
    拓展：
        1.a << 1 | 1 == a * 2 + 1
        2.怎么把int类型的数，提取出最右侧的1来？ N & ((~N)+1)
            例如： 0011 0011 0000  --> 0000 0001 0000
             N    =  0011 0011 0000
            ~N    =  1100 1100 1111
            ~N + 1=  1100 1101 0000
             N & (~N + 1) = 0000 0001 0000

7.排序总结
                时间复杂度   额外空间复杂度     稳定性
    选择排序        O(N^2)      O(1)           无
    冒泡排序        O(N^2)      O(1)           有
    插入排序        O(N^2)      O(1)           有
    归并排序        O(N*logN)   O(N)           有
    随机快排        O(N*logN)   O(logN)        无
    堆 排序         O(N*logN)   O(1)           无

    计数排序        O(N)       O(M)            有
    基数排序        O(N)       O(N)            有

8.链表
    单双链表结构
    1> 单链表和双链表如何反转
    2> 删除链表中指定值的node节点

9.栈和队列
    栈：数据先进后出，犹如弹夹       push() pop()  peek()   isEmpty()
    队列：数据先进先出，好似排队     add()  poll() peek()   isEmpty()
    1> 双向链表实现栈和队列
    2> 数组实现栈和队列
    3> 实现一个特殊的栈，在基本功能的基础上再实现返回栈中最小元素的功能，且pop,push,getMin时间复杂度都是O(1)
    4> 如何用栈结构实现队列结构
    5> 如何用队列结构实现栈结构

10.递归
        剖析递归行为和递归行为时间复杂度的估算
        master公式的使用
        T(N) = a*T(N/b) + O(N^d)   a*T(N/b)=递归行为的复杂度  O(N^d)=非递归程序的复杂度
        1) log(b,a) > d -> 复杂度为O(N^log(b,a))
        2) log(b,a) = d -> 复杂度为O(N^d * logN)
        3) log(b,a) < d -> 复杂度为O(N^d)

    1> 求数组arr[L...R]中的最大值，用递归实现。T(N) = 2*T(N/2) + O(N^0) = O(N^log(b,a)) = O(N^log(2,2)) = O(N)
        思路：1.将[L...R]范围分成左右两半。左：[L .. mid] 右：[mid+1 .. R]
             2.左部分求最大值，右部分求最大值
             3.[L...R]范围上的最大值，是max{左部分最大值,右部分最大值}
             注意：2.是个递归过程，当范围上只有一个数，就可以不用递归了

11.哈希表(HashSet,HashMap)
    1）哈希表再使用层面上可以理解为一种集合机构
    2）如果只有key，没有伴随数据value，可以使用HashSet结构
    3）如果既有key，又有伴随数据value，可以使用HashMap结构
    4）有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事
    5）使用哈希表增(put)，删(remove)，改(put)和查(get)的操作，可以认为时间复杂度为O(1)，但是常数项时间比较大
    6）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小
    7）放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节
    8）常用方法：增(put)，删(remove)，改(put)，查(get)，是否存在(containsKey) 时间复杂度都是O(1)

12.有序表(TreeSet,TreeMap)
    1）有序表在使用层面上可以理解为一种集合结构
    2）如果只有key，没有伴随数据value，可以使用TreeSet结构
    3）如果既有key，又有伴随数据value，可以使用TreeMap结构
    4）有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
    5）有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
    6）红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
    7）放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
    8）放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占用是这个东西内存地址的大小
    9）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度
    有序表固定操作
    1）增(put)，删(remove)，改(put)，查(get)，是否存在(containsKey)
    2）K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。
    3）K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。
    4）K floorKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，<=key的第一个。
    5）K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，>=key的第一个。
    注意：以上所有操作时间复杂度都是O(logN)
    比较器：
        1.实现Comparator<T>接口 重写compare(Object o1,Object o2)方法
        2.让元素具有比较性，实现Comparable接口，重写compareTo(Object o)方法